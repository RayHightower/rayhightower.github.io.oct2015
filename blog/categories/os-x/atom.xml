<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: OS X | RayHightower.com]]></title>
  <link href="http://RayHightower.com/blog/categories/os-x/atom.xml" rel="self"/>
  <link href="http://RayHightower.com/"/>
  <updated>2014-08-22T00:04:23-05:00</updated>
  <id>http://RayHightower.com/</id>
  <author>
    <name><![CDATA[Raymond T. Hightower - Chicago Ruby on Rails & iOS Developer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Managing Dotfiles]]></title>
    <link href="http://RayHightower.com/blog/2014/04/15/managing-dotfiles/"/>
    <updated>2014-04-15T17:13:00-05:00</updated>
    <id>http://RayHightower.com/blog/2014/04/15/managing-dotfiles</id>
    <content type="html"><![CDATA[<p>Dotfiles, the configuration files used by Unix-like machines, can become disorganized over time. Entropy rules! This article describes my recent attempt to bring order to dotfile chaos. The steps can be summarized as follows:</p>

<ul>
<li>Move the non-private dotfiles (dotfiles that will be viewed by others on Github) into a directory called <code>~/.dotfiles</code>.</li>
<li>From the <code>home</code> directory, create a symbolic link to each dotfile in the <code>~/.dotfiles</code> directory.</li>
<li>Use Git to manage the <code>~/.dotfiles</code> directory, and share it on GitHub.</li>
</ul>


<p>Dotfiles are normally hidden when you try to view them in the Mac OS X Finder. To view them from the command prompt, use <code>$ ls -al</code>.</p>

<!--more-->


<p>```bash
~/.dotfiles[master]$ ls -al
total 40
drwxr-xr-x   8 rth  staff   272 Apr 14 01:44 .
drwxr-xr-x+ 71 rth  staff  2414 Apr 14 02:12 ..
-rwxr-xr-x   1 rth  staff  3455 Apr 13 16:01 .bash_profile
drwxr-xr-x  14 rth  staff   476 Apr 14 02:25 .git
-rw-r&mdash;r&mdash;   1 rth  staff  1649 Apr 13 16:44 .gitk
-rw-r&mdash;r&mdash;   1 rth  staff  1760 Apr 13 16:10 .irbrc
-rw-r&mdash;r&mdash;   1 rth  staff   118 Aug 22  2013 .zprofile
-rw-r&mdash;r&mdash;   1 rth  staff   375 Apr 14 01:44 README.mdown</p>

<p>~/.dotfiles[master]$
```</p>

<p>The <a href="https://github.com/RayHightower/.dotfiles/blob/master/.bash_profile">.bash_profile</a> in this example has grown to include aliases, path specifications, and a script that shows the current Git branch as part of the command prompt. The file also contains two aliases useful for showing or hiding dotfiles in the Finder: <code>showdots</code> and <code>hidedots</code>.</p>

<h3>Putting Dotfiles in One Directory</h3>

<p>Dotfiles are normally created in the user&rsquo;s home directory. For organization purposes, I moved my non-private dotfiles into a directory called <code>.dotfiles</code>, listed above. Unix makes this easy. First, move to the home directory and create <code>~/.dotfiles</code>.</p>

<p>```bash
~$ cd ~</p>

<p>~$ mkdir .dotfiles</p>

<p>~$</p>

<p>```</p>

<p><em>Note: Dotfiles can sometimes include private information. If you don&rsquo;t want to share information in a particular dotfile, don&rsquo;t put it on GitHub!</em></p>

<p>In this example, we&rsquo;ll only move one file, <code>.bash_profile</code>.</p>

<p>```bash</p>

<p>~$ cd .dotfiles/</p>

<p>$ mv ../.bash_profile .</p>

<p>$</p>

<p>```</p>

<h3>Symbolic Links</h3>

<p>Symbolic links ensure that executables can find our dotfiles as needed.</p>

<p>```bash</p>

<p>$ cd ~</p>

<p>$ ln -s ~/.dotfiles/.bash_profile</p>

<p>$ ls -al
total 8
drwxr-xr-x   3 rth  staff   102 Apr 14 19:48 .
drwxr-xr-x+ 73 rth  staff  2482 Apr 14 19:47 ..
lrwxr-xr-x   1 rth  staff    34 Apr 14 19:48 .bash_profile &ndash;> /Users/rth/.dotfiles/.bash_profile</p>

<p>$</p>

<p>```</p>

<p>In the above example, we created a symbolic link called <code>.bash_profile</code> to the real <code>~/.dotfiles/.bash_profile</code> located in the <code>.dotfiles</code> directory. That way, any program that&rsquo;s looking for the <code>.bash_profile</code> file in the home directory will find what it needs, even though the file is somewhere else.</p>

<h3>Why Use Git to Manage Dotfiles?</h3>

<p>Git is a great tool for managing files that change over time. Dotfiles can change as we install new software or tweak our development environment. If we make a mistake, or if an installation script makes a mistake, we can use Git to roll back in history to a pre-mistake version of the dotfile.</p>

<h3>Don&rsquo;t Make All Dotfiles Public</h3>

<p>There are some dotfiles that you don&rsquo;t want to share publicly. For example, <code>.bash_history</code> contains all of the commands that have been executed in the shell. Do you really want the world that you sometimes <code>$ ssh myuserid@[embarassingdomainname].com</code>? Probably not. If you think that a dotfile might contain personal or confidential information, no need to broadcast it.</p>

<h3>Learning More About Dotfiles</h3>

<p>Most of my dotfiles, like <code>.bash_profile</code>, don&rsquo;t contain anything private. In fact, most of what I know about dotfiles has come from other developers via books, user groups, blogs, and spelunking through GitHub. Dotfile collections by <a href="https://github.com/hashrocket/dotmatrix">Hashrocket</a> and <a href="https://github.com/thoughtbot/dotfiles">Thoughtbot</a> are  especially good. My <code>~/.dotfiles</code> directory is available for public viewing on <a href="https://github.com/RayHightower/.dotfiles">GitHub</a>.</p>

<p>If you&rsquo;re doing something especially cool with your dotfiles, let&rsquo;s hear about it!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How .gitignore Works]]></title>
    <link href="http://RayHightower.com/blog/2014/03/25/how-gitignore-works/"/>
    <updated>2014-03-25T18:20:00-05:00</updated>
    <id>http://RayHightower.com/blog/2014/03/25/how-gitignore-works</id>
    <content type="html"><![CDATA[<p>Earlier today I ran into a Git issue within a RubyMotion project. I added a directory to the project&rsquo;s <code>.gitignore</code> file, but Git seemed to ignore my ignore. Expressed more clearly, Git continued to track a directory that I explicitly told it to ignore.</p>

<p>What?</p>

<p>Either there was a bug in Git, or my understanding of <code>.gitignore</code> was incomplete. It was time for me to dig in and learn more about <code>.gitignore</code>.</p>

<!--more-->


<h3>What I Learned About .gitignore</h3>

<p>The root cause of my problem: Once Git has begun tracking a file or directory, adding it to <code>.gitignore</code> changes nothing. Git will continue to track the file unless we explicitly tell Git to stop tracking the file.</p>

<p>```bash
$ git rm &mdash;cached [filename]</p>

<p>$
```</p>

<p>Or, if you want to stop tracking an entire directory (like me in this case)&hellip;</p>

<p>```bash
$ git rm -r &mdash;cached [directoryname]</p>

<p>$
```</p>

<p>The <code>-r</code> flag will tell Git to stop tracking all of the sub-directories and files within <code>directoryname</code>, recursively.</p>

<p>Git was behaving exactly as designed.</p>

<h3>Penalty</h3>

<p>I should have known this a long time ago. My penalty: A public admission :&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fixing MacVim on OS X Mavericks]]></title>
    <link href="http://RayHightower.com/blog/2014/03/04/fixing-macvim-on-osx-mavericks/"/>
    <updated>2014-03-04T14:48:00-06:00</updated>
    <id>http://RayHightower.com/blog/2014/03/04/fixing-macvim-on-osx-mavericks</id>
    <content type="html"><![CDATA[<p>Experience told me to delay upgrading to OS X Mavericks for as long as possible because the upgrade would likely break my dev environment. Sure enough, the upgrade broke <a href="/blog/2013/01/12/why-i-use-vim/">MacVim</a>.</p>

<p>```bash
~$ which mvim</p>

<p>~$
```</p>

<p>The &lsquo;nix <code>which</code> command returned a null response when asked about MacVim. Not cool, Mavericks!</p>

<!--more-->


<p>Fortunately, I‚Äôm running <a href="/blog/2014/02/12/homebrew-fundamentals/">Homebrew</a>. After the standard <code>brew doctor</code> and <code>brew update</code>, the following resolved the MacVim problem:</p>

<p>```bash
~$ brew uninstall macvim
Uninstalling /usr/local/Cellar/macvim/7.4-70&hellip;</p>

<p>~$
```</p>

<p>followed by‚Ä¶</p>

<p>```bash
~$ brew install macvim
==> Downloading <a href="https://github.com/b4winckler/macvim/archive/snapshot-72.tar.gz">https://github.com/b4winckler/macvim/archive/snapshot-72.tar.gz</a></p>

<h6>################################################################## 100.0%</h6>

<p>==> ./configure &mdash;with-features=huge &mdash;enable-multibyte &mdash;with-macarchs=x86_64 &mdash;enable-perlinterp &mdash;enable-rubyinterp &mdash;enable-tcli
==> make
==> Caveats
.app bundles were installed.
Run <code>brew linkapps</code> to symlink these to /Applications.
==> Summary
üç∫  /usr/local/Cellar/macvim/7.4-72: 1799 files, 28M, built in 37 seconds</p>

<p>~$
```</p>

<p>And now‚Ä¶</p>

<p>```bash
~$ which mvim
/usr/local/bin/mvim</p>

<p>~$
```</p>

<p>Whew. Homebrew saves the day again!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BeagleBone Black Running Ubuntu: Part1]]></title>
    <link href="http://RayHightower.com/blog/2014/01/02/beaglebone-black-ubuntu-part-1/"/>
    <updated>2014-01-02T15:59:00-06:00</updated>
    <id>http://RayHightower.com/blog/2014/01/02/beaglebone-black-ubuntu-part-1</id>
    <content type="html"><![CDATA[<p><span class='caption-wrapper center'><img class='caption' src='/images/beaglebone-black-ubuntu-ruby-rails.jpg' width='' height='' alt='BeagleBone Black running Ubuntu, Ruby, &amp; Rails.' title='BeagleBone Black running Ubuntu, Ruby, &amp; Rails.'><span class='caption-text'>BeagleBone Black running Ubuntu, Ruby, &amp; Rails.</span></span></p>

<p>The above screenshot shows a BeagleBone Black running Ubuntu, Ruby, and Rails. Why Ubuntu? The Bone comes <a href="/blog/2013/05/22/beaglebone-black-running-ruby-on-rails/">pre-installed with √Öngstr√∂m</a>, and it boots as soon as you unbox it. Why not stick with √Öngstr√∂m?</p>

<p>My opinion: The factory standard is fine, but it&rsquo;s always good to have options. Here&rsquo;s why I decided to try Ubuntu on the BeagleBone Black&hellip;</p>

<!--more-->


<ul>
<li>Ubuntu documentation is plentiful. Books, blogs, and videos are readily available.</li>
<li>The Ubuntu community is huge. When a dev runs into an Ubuntu-related snag, it&rsquo;s likely that another dev has encountered a similar problem, and they can collaborate on a solution.</li>
<li>Ubuntu is the distro that I&rsquo;m most familiar with. <a href="http://wisdomgroup.com">WisdomGroup</a> uses Ubuntu for multiple projects. With a common operating system, knowledge gained in one environment is immediately useful in another.</li>
<li>Prepping for <a href="/blog/2013/06/22/preparing-for-parallella-64-cores-installing-go-on-mac-os-x/">Parallella</a>, the 64-core single-board computer that will cost about two hundred bucks. The Parallella is currently in short supply. When it becomes available, it will run Ubuntu. Experience with other single-board computers, especially those running Ubuntu, will prove useful.</li>
</ul>


<p>This article will show how to install Ubuntu on the BeagleBone Black. <em>Gotchas</em> will be pointed out along the way. Where possible, I will explain the reasons behind my decisions so that you can make different choices if you like.</p>

<p>For a comparable examination of the Raspberry Pi, take a look at <a href="/blog/2012/12/03/ruby-on-raspberry-pi/">Ruby on Raspberry Pi</a>.</p>

<h3>First Gotcha: Ubuntu 13 on the Bone</h3>

<p>As of this writing, Ubuntu 12 runs well on the BeagleBone Black, but Ubuntu 13 does not. My Ubuntu 13 installation appeared to be successful, but the Ubuntu 13 GUI hung up immediately after login. The Ubuntu 13 command line interface worked fine.</p>

<p>A quick search on Google reveals that others encountered similar roadblocks with version 13. One successful Bone/13 installation was used via SSH, not interactively via keyboard and GUI. Hopefully this will change with future updates. Or, since we&rsquo;re dealing in the open source world, maybe I can pitch in and help.</p>

<p>Due to the issues encountered with version 13, everything in this article will focus on Ubuntu 12.</p>

<h3>Materials Needed for Installing Ubuntu 12</h3>

<p>In addition to the BeagleBone Black, the following items should be gathered before installation:</p>

<ul>
<li>Micro SD card of at least 8GB. It&rsquo;s possible to perform the installation with a 4GB card, but that won&rsquo;t leave much room for Ubuntu applications.</li>
<li>SD card reader/writer. Recent versions of Apple&rsquo;s MacBook Pro come with an SD reader/writer built in.</li>
<li>SD to Micro-SD card adapter. The Bone is designed for micro SD, and the MacBook Pro is designed for full-sized SD. Some micro SD packages come with the adapter.</li>
<li>A monitor that accepts HDMI input.</li>
<li>USB keyboard and mouse.</li>
<li>Micro HDMI to HDMI adapter. The Bone uses micro HDMI for video output, but your monitor probably uses full-sized HDMI.</li>
<li>External 5V power adapter for the Bone. Personally, I trust the standard 5v power input more than I trust the power provided via USB. One never knows if USB can provide sufficient (and stable) amperage for a circuit board. Power fluctuations can lead to strange behavior, including video flickering.</li>
<li>Ethernet cable with RJ-45 ends.</li>
<li>A fast internet connection.</li>
</ul>


<p>The standard <a href="/sudo-disclaimer">sudo disclaimer</a> applies.</p>

<h3>Homebrew Required</h3>

<p>Homebrew is the easiest way to install &lsquo;nix utilities on Mac OS X. We need Homebrew in order to install some of the utilities needed to burn the SD card. The one-line Homebrew installation command is given on the  <a href="http://brew.sh/">Homebrew site</a>.</p>

<p>Each time we use Homebrew, we run <code>$ brew doctor</code> and <code>$ brew update</code> to make sure the packages are up-to-date.</p>

<p><code>``bash
$ brew doctor
Warning: Your Homebrew is outdated.
You haven't updated for at least 24 hours, this is a long time in brewland!
To update Homebrew, run</code>brew update`.</p>

<p>$ brew update
Updated Homebrew from a2e44659 to 4c7bc9ec.</p>

<p>$ brew doctor
Your system is ready to brew.
```</p>

<h3>The xz Extraction Utility</h3>

<p>Disk image files are downloaded in a compressed format. We need the <code>xz</code> utility in order to extract the files into something usable. If you already have Homebrew installed, this command will install <code>xz</code> for you.</p>

<p><code>bash
$ brew install xz
</code></p>

<h3>Test the BeagleBone Black First</h3>

<p>Power up your BeagleBone Black and make sure it runs with the built-in √Öngstr√∂m Linux installation. One great thing about the Bone is that it will <a href="/blog/2013/05/22/beaglebone-black-running-ruby-on-rails/">boot to the √Öngstr√∂m GUI</a> straight out of the box, with no prior configuration.</p>

<p>If the GUI boots, then you&rsquo;re in good shape.</p>

<p>If the GUI doesn&rsquo;t boot, it may have been damaged in a prior experiement. Embarassing note: I started looking for a way to install Ubuntu on the Bone because I broke my √Öngstr√∂m installation. What can I say&hellip; I learn more from destructive experiments. Faced with a non-booting Bone, I had two choices.</p>

<ol>
<li>Re-build √Öngstr√∂m.</li>
<li>Try something different, like Ubuntu.</li>
</ol>


<p>Option two worked well!</p>

<h3>Prep the SD Card</h3>

<p>Apple&rsquo;s Disk Utility is a convenient tool for wiping the SD card.  Standard warnings about any disk utility apply. Double-check everything, and make sure you&rsquo;re wiping the right volume, or you could lose all of your data.</p>

<p>Next, download the Ubuntu 12.04 image from <a href="http://www.armhf.com/index.php/boards/beaglebone-black/#precise">http://armhf.com</a>.</p>

<p>Extract the image using the <code>xz</code> utility.
<code>bash
$ xz ubuntu-precise-12.04.3-armhf-3.8.13-bone30.img.xz
</code></p>

<p>The extracted image will have a <code>.img</code> file extension. We will use the <code>dd</code> utility to burn the disk image to the SD card. But first, we need to determine the designation of the SD card.</p>

<h3>Find the SD Card Designation</h3>

<p>In order to burn the SD card, we need to make sure we target it correctly. Here&rsquo;s how to figure out which device to target.</p>

<p><code>$ diskutil list</code> will show all of the partitions mounted on the system.</p>

<p><code>bash
$ diskutil list
/dev/disk0
   #:                       TYPE NAME                    SIZE       IDENTIFIER
   0:      GUID_partition_scheme                        *500.3 GB   disk0
   1:                        EFI                         209.7 MB   disk0s1
   2:                  Apple_HFS Macintosh HD            499.4 GB   disk0s2
   3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3
/dev/disk1
   #:                       TYPE NAME                    SIZE       IDENTIFIER
   0:     FDisk_partition_scheme                        *8.0 GB     disk1
</code>
I happen to know that my SD Card is 8.0 GB in capacity, and my system also has a 500 GB SSD. The goal is to burn the SD card while leaving the 500 GB SSD (home of the Mac OS X operating system and all of my data) intact. From the <code>$ diskutil list</code> report, I can see that the SD card&rsquo;s designation <em>in my system</em> is <code>/dev/disk1</code>.</p>

<p>Note the italicized words <em>in my system</em>. Your system is probably different, especially if you have a DVD drive or a second hard drive. I have neither of those. The SD card&rsquo;s designation will be different in each system where it is mounted depending on the number and location of the drives that are already there.</p>

<p>Now that we know the SD card&rsquo;s designation, we can unmount it. We unmount the drive (but leave the card inserted in the reader) so that it can be written with the Ubuntu disk image.</p>

<p><code>bash
$ diskutil unmountDisk /dev/disk1
Unmount of all volumes on disk1 was successful
</code></p>

<p>Looks like the SD card was unmounted successfully. Now we can write the
Ubuntu image with the <code>dd</code> utility.</p>

<h3>Writing the Ubuntu Image</h3>

<p>The following command will write the decompressed Ubuntu image to the SD
card.</p>

<p>```bash
$ sudo dd bs=1m if=ubuntu-precise-12.04.3-armhf-3.8.13-bone30.img of=/dev/disk1</p>

<p>```</p>

<p>Note that it may take up to an hour for the image to be written.</p>

<p>One drawback of using the command line is that there is no gauge to tell you how much progress the utility is making. Fortunately, I stumbled upon a way to measure progress at <a href="http://elinux.org">eLinux.org</a>. While the command line utility is running, and while that window has focus, type <code>control-T</code>. A few seconds later, the terminal window will show a brief activity report.</p>

<p>Here&rsquo;s a report from the first time I struck <code>control-T</code> &hellip;</p>

<p><code>bash
load: 2.03  cmd: dd 75608 uninterruptible 0.00u 0.54s
40+0 records in
39+0 records out
</code></p>

<p>We can strike <code>control-T</code> again to receive additional updates. The numbers will tell us if we are making progress. Don&rsquo;t get carried away with <code>control-T</code>. A watched pot never boils :&ndash;)</p>

<h3>Booting with the New SD Card</h3>

<p>The terminal will return to the command prompt after the Ubuntu image has been written to the SD card. Now it&rsquo;s time to boot with the new image.</p>

<ol>
<li>Eject the SD card from the Mac.</li>
<li>Remove power from the BeagleBone Black, and insert the micro SD card.</li>
<li>Note the location of the &ldquo;boot&rdquo; button on the Bone. It&rsquo;s the micro switch closest to the USB port. We will need to hold this switch down while powering up the Bone.</li>
</ol>


<p>A few notes about item #3. It takes some juggling to hold down a micro switch while plugging in power to the board. I found it easier to plug the power adapter into a powered-off surge suppressor, hold down the microswitch, and then power-on the surge suppressor with my elbow.  Sounds ridiculous, but it worked.</p>

<p>About sixty seconds after boot, the Linux penguin appeared in the upper left corner of the Bone display. And then the login prompt appeared.</p>

<p>Another note about the &ldquo;boot&rdquo; switch: It looks like the Bone will boot into the SD&rsquo;s operating system (instead of the eMMC flash OS where Angstrom resides) without the micro switch if the switch was used in the previous boot. I haven&rsquo;t rebooted enough times to test this thoroughly.</p>

<h3>Default Credentials for Ubuntu on BeagleBone Black</h3>

<p>Ubuntu&rsquo;s default BeagleBone Black login credentials are shown here because I always end up hunting for these when I need them. It&rsquo;s much easier to have information at one&rsquo;s fingertips.</p>

<p><code>bash
login: ubuntu
pw: ubuntu
</code></p>

<h3>End of Part One</h3>

<p>This marks the end of part one of this series about BeagleBone Black and Ubuntu.</p>

<p><a href="/blog/2014/01/06/beaglebone-black-ubuntu-ruby-rails-part-2/">Part two</a> covers <a href="/blog/2014/01/06/beaglebone-black-ubuntu-ruby-rails-part-2/">Ruby on BeagleBone Black</a>, with information about&hellip;</p>

<ul>
<li>Getting the GUI running, including a disk resizing <em>gotcha</em>.</li>
<li>Installing Ruby, including a Ruby Version Manager (RVM) <em>gotcha</em>.</li>
<li>Installing Rails, and how to handle a JavaScript runtime <em>gotcha</em>.</li>
</ul>


<p>Stay tuned!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OS X and RubyMotion, Finishing Up]]></title>
    <link href="http://RayHightower.com/blog/2013/11/11/os-x-and-rubymotion-finishing-up/"/>
    <updated>2013-11-11T19:03:00-06:00</updated>
    <id>http://RayHightower.com/blog/2013/11/11/os-x-and-rubymotion-finishing-up</id>
    <content type="html"><![CDATA[<p><span class='caption-wrapper right'><img class='caption' src='/images/show-package-contents.png' width='' height='' alt='' title=''><span class='caption-text'></span></span>
There is something I neglected to cover in a previous blog post, <a href="/blog/2013/11/01/building-an-os-x-app-with-rubymotion/">Building an OS X App With RubyMotion</a>. Once you&rsquo;ve written the OS X app, where do you find the executable, and how do you add it to the <code>Applications</code> folder on the Mac?</p>

<p>Long-time Mac enthusiasts may already know how to do this. The information is included here for completeness.</p>

<h3>Find, Drag, and Drop</h3>

<p>First thing to note: A Mac app named [random-app].app is actually a directory, even though it appears to be a file when viewed in the <code>Applications</code> folder. If you&rsquo;re curious, right-click on any app in the <code>Applications</code> folder and choose <code>Show Package Contents</code> from the speed menu.</p>

<!--more-->


<p>After compilation, RubyMotion puts all of the executables in the app&rsquo;s <code>build/</code> directory. Using Finder, drag the folder named <code>[your-app-name].app</code> into the <code>Applications</code> folder.</p>

<p>Or, if you prefer the command line‚Ä¶</p>

<p><code>bash
$ cd [root-directory-of-your-app]
$ cp build/MacOSX-10.8-Development/[your-app-name].app /Applications
$
</code></p>

<p>It doesn&rsquo;t really matter whether we copy the file or move it.  RubyMotion creates a new one with every build, when we type <code>rake</code>.</p>

<h3>Launch at Login</h3>

<p>I want the EjectDisks utility to be always available, so it would be good to have it launch automatically at login. That behavior is managed in the <code>Users and Groups</code> preference pane, shown below:</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/launch-at-login.png' width='' height='' alt='' title=''><span class='caption-text'></span></span></p>

<p>Click the <code>+</code> sign, navigate to the app you want to launch at login time (in this case, EjectDisks) and select it. Done.</p>
]]></content>
  </entry>
  
</feed>
