<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: beaglebone black | RayHightower.com]]></title>
  <link href="http://RayHightower.com/blog/categories/beaglebone-black/atom.xml" rel="self"/>
  <link href="http://RayHightower.com/"/>
  <updated>2015-06-24T16:26:12-05:00</updated>
  <id>http://RayHightower.com/</id>
  <author>
    <name><![CDATA[Raymond T. Hightower - Chicago Ruby on Rails & iOS Developer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ESC Programming and Calibration for OpenROV]]></title>
    <link href="http://RayHightower.com/blog/2014/08/21/esc-programming-and-calibration-for-openrov/"/>
    <updated>2014-08-21T16:27:00-05:00</updated>
    <id>http://RayHightower.com/blog/2014/08/21/esc-programming-and-calibration-for-openrov</id>
    <content type="html"><![CDATA[<p><span class='caption-wrapper middle'><img class='caption' src='/images/openrov_esc.jpg' width='' height='' alt='Three ESCs, one for each motor. Each ESC has a switch and a power/signal connector.' title='Three ESCs, one for each motor. Each ESC has a switch and a power/signal connector.'><span class='caption-text'>Three ESCs, one for each motor. Each ESC has a switch and a power/signal connector.</span></span></p>

<h3>ESCs: New Experience for Me</h3>

<p>Electronic speed controllers (ESCs) were completely new to me when I first assembled my <a href="/blog/2014/06/16/citizen-science-with-openrov/">OpenROV</a>. This article documents my initial misunderstanding (and eventual understanding) of ESCs so that future builders can move forward with fewer glitches.</p>

<!--more-->


<p>The photo at the top of this page shows an OpenROV controller board, a
BeagleBone Black, and three ESCs. This article will focus on the ESCs.</p>

<h3>Remember This About ESCs</h3>

<p>Until all three ESCs are programmed <em>and</em> calibrated, the OpenROV might behave erratically. For example&hellip;</p>

<ul>
<li>The servo that moves the camera up and down will not respond to keyboard commands.</li>
<li>When you turn one ESC switch on, an unrelated motor (or motors, plural) might start spinning. In my case, turning on one ESC (any of the three ESCs) caused two motors to spin.</li>
</ul>


<p>In my case, the programming was correct, but I <a href="/blog/2014/08/19/openrov-assembly-challenges/">dropped the ball on calibration</a>. And when the motors responded out-of-sync with the switches, I thought I had soldered some connections incorrectly. De-soldering and re-soldering connections would have been a ton of extra work, and that would not have solved the problem.</p>

<p>I reached out to the <a href="http://openrov.com/forum">forum</a> where OpenROV engineer Brian Adams pointed me in the right direction. Brian&rsquo;s diplomatic response could be summarized as <em>RTFM</em>. So I re-RTFM&rsquo;d, and it worked!</p>

<p>The bottom line: Do the ESC programming and calibration first. If the OpenROV misbehaves, re-check programming and calibration before considering other solutions.</p>

<h3>Why Use ESCs?</h3>

<p>Since ESCs require so many steps (programming and calibration) we might logically ask: <em>Why use ESCs at all?</em> Why not use simple analog motors without controllers and call it a day?</p>

<p>We use ESCs because the benefits outweigh the work required to configure them. It&rsquo;s all about control. By using an ESC to control each motor, we can use software to specify the <em>exact</em> number of RPMs and direction for each motor. We can make any motor (or combination or motors) start, stop, or change direction on a dime. Even better: When we move a lever on our controller of choice (keyboard, game controller, etc.) software on the OpenROV controller board decides the exact number of RPMs for each motor at that instant. OpenROV pilots don&rsquo;t need to think about this process while it happens. It just works.</p>

<p>The pilot&rsquo;s finger moves a controller lever. The lever position gets sent to software on the OpenROV controller board, and the controller board tells each ESC what its corresponding motor should do.</p>

<p>In summary, we use ESCs so that OpenROV pilots can have greater control over movement.</p>

<h3>How to Re-Check ESC Programming</h3>

<p><span class='caption-wrapper right'><img class='caption' src='/images/esc_program_card.jpg' width='' height='' alt='ESC program card.' title='ESC program card.'><span class='caption-text'>ESC program card.</span></span>
Those of you with ESC experience already know about ESC program cards. I first learned about the cards while researching this problem. Amazing devices! Yes, it is possible to program ESCs using the series of button pushes and beeps in the OpenROV instructions. That&rsquo;s what I did, and it works. But a program card is faster. Amazon sells ESC program cards for less than fifteen dollars each. Well worth the investment, especially if you&rsquo;re programming ESCs for several OpenROVs.</p>

<h3>ESC Calibration Gotcha</h3>

<p>ESC calibration was tricky for me because turning on any of the three ESC switches caused two of my motors to spin: vertical and port. Further, since my electronics chassis was (mostly) assembled by the time I got to the calibration step, it wasn&rsquo;t easy for me to trace each power switch to its corresponding ESC.</p>

<p>So here&rsquo;s what I had to do.</p>

<p><span class='caption-wrapper right'><img class='caption' src='/images/openrov_esc_switch_labels.jpg' width='' height='' alt='ESC switch labels.' title='ESC switch labels.'><span class='caption-text'>ESC switch labels.</span></span></p>

<ul>
<li>First, I took everything apart, while keeping the electronic leads (those which had already been soldered) intact. I needed to do this so I could see where each wire was going.</li>
<li>Next, I labeled the back of each ESC switch with its corresponding ESC number. I did not want to go through the disassembly step again! The Brother P-Touch label maker was perfect for this step.</li>
<li>Finally, I followed the ESC calibration steps <em>while ignoring the behavior of the motors</em>. For example, turning on ESC1 caused the motors connected to ESC1 (port) <em>and</em> ESC2 (vertical) to spin. I ignored the motors while plowing through OpenROV&rsquo;s written calibration steps.</li>
</ul>


<h3>Modified Calibration Steps</h3>

<p>Here are the OpenROV calibration steps, with slight tweaks based on my personal experience.</p>

<p><span class='caption-wrapper right'><img class='caption' src='/images/openrov_calibration_sliders.jpg' width='' height='' alt='Click &ldquo;Diagnostics&rdquo; from the OpenROV cockpit.' title='Click &ldquo;Diagnostics&rdquo; from the OpenROV cockpit.'><span class='caption-text'>Click &ldquo;Diagnostics&rdquo; from the OpenROV cockpit.</span></span></p>

<ol>
<li>Each ESC switch has a red reset button. To turn the ESC on, move its slider switch toward the red reset button. The off position is in the opposite direction.</li>
<li>With all of the ESCs switched off, go ahead and power up the OpenROV. The motors should remain stationary at this point. Connect with the cockpit software and open the diagnostic pane.</li>
<li>Grab one ESC switch, and hold down its red reset button while powering it on. (At this point, two of my motors began spinning, V and P. I ignored the spinning motors while plowing through the rest of the steps.) You will hear a beeping noise. Let go of the reset button. (It will keep beeping which is fine). While it’s beeping, the red LED inside the corresponding ESC will flash in rhythm with the beeps.</li>
<li>Press reset once and you should hear a single beep. Move that motor&rsquo;s slider all the way to the right (or click the &ldquo;1&rdquo;) and then press the reset on the ESC again. You should get 2 beeps. The motor will not move during this step.</li>
<li>Move that motor&rsquo;s slider all the way to the left (or click the &ldquo;-1&rdquo;) and then press the reset on the ESC again. You will hear three beeps.</li>
<li>After a few seconds the motor will begin to spin. Switch off the ESC, and the motor will stop spinning.</li>
<li>Move the slider back to the middle (or click the &ldquo;0&rdquo;).</li>
<li>Repeat these steps with the next ESC until all three ESCs are done.</li>
</ol>


<p><span class='caption-wrapper right'><img class='caption' src='/images/openrov_lake_michigan_2.jpg' width='' height='' alt='OpenROV meets Lake Michigan.' title='OpenROV meets Lake Michigan.'><span class='caption-text'>OpenROV meets Lake Michigan.</span></span>
After calibration:</p>

<ul>
<li>With all three ESCs powered on, the motors remained stationary, as expected.</li>
<li>Each motor responded to the correct slider within the cockpit software&rsquo;s diagnostic pane.</li>
<li>The up/down servo for the camera responded correctly to the Q, A, and Z commands.</li>
<li>The motors responded to keyboard commands, as described within the cockpit&rsquo;s quick reference guide.</li>
</ul>


<p>In other words, calibration worked when I ignored the behavior of the motors while plowing through the steps.</p>

<h3>Success</h3>

<p>There is great satisfaction in solving an elusive problem. The OpenROV forum proved to be a powerful and useful resource. Next step: <a href="/blog/2014/08/22/openrov-meets-chicago-lake-michigan/">Piloting the OpenROV in Lake Michigan</a>.</p>

<p><em>Photo acknowledgement: The original version of the ESC photo was published in the <a href="http://openrov.dozuki.com/Guide/How+to+Assemble+OpenROV+2.6/6">OpenROV assembly manual</a>. Thanks OpenROV team!</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenROV Assembly Challenges]]></title>
    <link href="http://RayHightower.com/blog/2014/08/19/openrov-assembly-challenges/"/>
    <updated>2014-08-19T16:44:00-05:00</updated>
    <id>http://RayHightower.com/blog/2014/08/19/openrov-assembly-challenges</id>
    <content type="html"><![CDATA[<p><span class='caption-wrapper right'><img class='caption' src='/images/openrov_rth.jpg' width='' height='' alt='OpenROV fully assembled.' title='OpenROV fully assembled.'><span class='caption-text'>OpenROV fully assembled.</span></span>
I know this problem can be solved. I just haven’t figured it out yet, and I need help from the <a href="http://openrov.com/">OpenROV</a> community to do so.</p>

<p><em>Update: The OpenROV community delivered. Solution: <a href="/blog/2014/08/21/esc-programming-and-calibration-for-openrov/">ESC Programming and Calibration for OpenROV</a>.</em></p>

<h3>Parts That Work</h3>

<p>Software image updates on the Beaglebone Black work flawlessly thanks to scripts written by <a href="https://github.com/BrianAdams">Brian Adams</a> and <a href="https://github.com/codewithpassion">Dominick Fretz</a>. The cockpit software shows a real-time image from the camera, the LED lights are super-bright, and the lasers hold steady at 10cm apart. My fully assembled OpenROV passes the water submersion test. Yes, it’s waterproof, thanks to O-rings and silicon-based lubricant!</p>

<p>What about the motors? The motors work, almost. Could it be the
electronic speed control (ESC) settings, calibration, or less than
perfect soldering? That&rsquo;s where I need help.</p>

<!--more-->


<h3>Summary of Symptoms</h3>

<p>With the cockpit software running and attached to the OpenROV:</p>

<ul>
<li>If I turn on any of the three ESCs, two of the motors (vertical and port) start running at full blast. The starboard motor remains stationary.</li>
<li>While the V and P motors continue to run at full blast, the starboard motor responds to the cockpit slider controls as expected: +1 makes S run full blast on one direction, -1 sends S full blast in the other direction, and 0 stops the S motor completely. During this exercise, V and P continue at full blast.</li>
<li>Turning off the ESC stops the V and P motors.</li>
<li>When I turn on any of the ESCs, the camera servo jumps slightly, about 10 degrees. And then the V and P motors run full blast.</li>
</ul>


<p>When the cockpit software is not running (and the Google Chrome browser is completely closed):</p>

<ul>
<li>Turning on an ESC has no effect on the motors.</li>
<li>The camera servo jumps slightly, about 10 degrees, as it did with the cockpit software running. But the motors remain stationary.</li>
</ul>


<p>Interesting behavior!</p>

<h3>Double-Checking the ESC Settings</h3>

<p><span class='caption-wrapper right'><img class='caption' src='/images/esc_program_card.jpg' width='' height='' alt='ESC Program Card' title='ESC Program Card'><span class='caption-text'>ESC Program Card</span></span>
During troubleshooting, my first step was to double-check the electronic speed controller (ESC) settings. Setting the ESCs with the beep-and-button-push method was time consuming. And I was concerned that I may have made a mistake in counting the beeps.</p>

<p>Solution: I bought an ESC program card. Amazon sells them for less than fifteen dollars, well worth the price when you consider the peace of mind that the card brings. The program card shows each ESC setting with a clear 7-segment LED display, much easier than counting beeps!</p>

<p>According to the program card, all of the ESC settings are correct.</p>

<h3>Using a Power Supply Instead of Batteries</h3>

<p>All of the time spent troubleshooting drained the OpenROV batteries. So I devised a way to apply power directly to the OpenROV without batteries.</p>

<p><span class='caption-wrapper middle'><img class='caption' src='/images/openrov_power_supply.jpg' width='' height='' alt='Directly connected to power supply.' title='Directly connected to power supply.'><span class='caption-text'>Directly connected to power supply.</span></span></p>

<p>The photo reveals the random condition of my work surface, so here&rsquo;s a verbal description of this hack:</p>

<ul>
<li>In the background, a power supply set to 12 volts</li>
<li><code>+</code> lead (red) connected to the <code>+</code> leads of the battery containers, via a wire acting as a Y-connector.</li>
<li><code>-</code> lead (black) connected to a ground terminal on the OpenROV controller board through a black jumper cable</li>
</ul>


<p>I find that this hack works best if I connect the 12 volt setup first while the Topside Adapter is powered off. Applying power (via USB) to the Topside Adapter turns the entire assembly on.</p>

<p>If you&rsquo;re reading this section and you know a better way for me to connect the power supply, please advise in the comments section below.</p>

<h3>Advice Welcome</h3>

<p>I&rsquo;m not sure where to look next to solve the challenge with the motors. Maybe I skipped a step somewhere during assembly? Advice welcome!</p>

<p><em>Update: As noted at the beginning of this article, this problem has been solved. Solution: <a href="/blog/2014/08/21/esc-programming-and-calibration-for-openrov/">ESC Programming and Calibration for OpenROV</a>.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Citizen Science With OpenROV]]></title>
    <link href="http://RayHightower.com/blog/2014/06/16/citizen-science-with-openrov/"/>
    <updated>2014-06-16T17:46:00-05:00</updated>
    <id>http://RayHightower.com/blog/2014/06/16/citizen-science-with-openrov</id>
    <content type="html"><![CDATA[<blockquote><p>In the early days of robots people said, &lsquo;Oh, let&rsquo;s build a robot&rsquo; and what&rsquo;s the first thought? You make a robot look like a human and do human things. That&rsquo;s so 1950s. We are so past that.
<br/>~Neil deGrasse Tyson</p></blockquote>

<p><span class='caption-wrapper right'><img class='caption' src='/images/openrov-uw.jpg' width='' height='' alt='OpenROV: Underwater robot running Node.js.' title='OpenROV: Underwater robot running Node.js.'><span class='caption-text'>OpenROV: Underwater robot running Node.js.</span></span>
<a href="http://openrov.com">OpenROV</a> is an underwater robot, roughly the size of a toaster, and definitely not human-shaped. The device is controlled through a Node.js-based web app. Former NASA researcher Eric Stackpole and Make Magazine columnist David Lang are on a mission to democratize ocean exploration in the same way that Jobs and Woz sparked the democratization of  computing. Eric and David pooled their talents to launch OpenROV, building on the foundation laid by Moore’s Law and the open source software movement.</p>

<p>OpenROV&rsquo;s ingredients are an impressive mix of open source goodness&hellip;</p>

<p><span class='caption-wrapper right'><img class='caption' src='/images/BeagleBoneBlack_Linux_Nodejs.jpg' width='' height='' alt='BeagleBone Black running Linux &amp; Node.js.' title='BeagleBone Black running Linux &amp; Node.js.'><span class='caption-text'>BeagleBone Black running Linux &amp; Node.js.</span></span></p>

<ul>
<li>BeagleBone Black &ndash; an open-source single-board computer, smaller than a deck of cards, running Linux.</li>
<li>Linux &ndash; specifically, the Ubuntu distribution.</li>
<li>Node.js &ndash; platform for building web applications, based on Google’s V8 JavaScript engine. Thanks to Node.js, any laptop running a web browser can control the OpenROV.</li>
<li>Arduino &ndash; inexpensive micro-controller commonly used in robotics projects.</li>
<li>TCP/IP &ndash; the communication protocol of the Internet. TCP/IP handles all communications (commands, video) between the OpenROV and the pilot’s laptop.</li>
</ul>


<p>The OpenROV team has released all of their <a href="https://github.com/openrov">schematics and source code</a> to the open source community, hence the word “open” in the company name. If you think the open source aspects of OpenROV are exciting, wait until you hear about the company&rsquo;s main mission: Underwater exploration.</p>

<!--more-->


<p>Eric and David were kind enough to invite me to their lab/manufacturing facility in Berkeley, California recently. Thank you, OpenROV makers!</p>

<h3>Remotely Operated Vehicles</h3>

<p><span class='caption-wrapper right'><img class='caption' src='/images/controller.jpg' width='' height='' alt='Laptop, browser, and game controller.' title='Laptop, browser, and game controller.'><span class='caption-text'>Laptop, browser, and game controller.</span></span>
ROV is short for remotely operated vehicle, an underwater robot. Scientists use ROVs to study marine life. Oil companies use ROVs for underwater construction and inspections. Industry-grade ROVs are priced at $30,000 on the low-end, while a <a href="http://www.mbari.org/twenty/Tiburon.htm">custom ROV can cost several million dollars</a>.</p>

<p>The OpenROV team was convinced that they could design and build an ROV small enough to fit in a suitcase, and easy enough for a citizen scientist to assemble and maintain. Targeting the general public meant achieving a relatively low price point: under one thousand dollars ($1,000.00).</p>

<p>They did it. The device is successful, and you can <a href="http://store.openrov.com/">buy an OpenROV</a> kit today for $849.00.</p>

<p>Movements are controlled via a USB-connected video game controller. A Bluetooth-equipped controller should work just as well. Some users will prefer the laptop keyboard; that works too.</p>

<p>In other words, the computer that you’re using to read this article can probably control the OpenROV.</p>

<h3>Citizen Science</h3>

<p>Our world will always need professional scientists, people working in academia and in industry to push the frontier of knowledge. Some scientific problems require the attention of PhD-level professionals, while other problems are better solved through crowdsourcing. Enter the <a href="http://en.wikipedia.org/wiki/Citizen_science">citizen scientist</a>.</p>

<p>Professional scientists are good at analyzing data, because that&rsquo;s what they have trained themselves to do. But data gathering requires less training than analysis. Citizen science and crowdsourcing work when there&rsquo;s an overwhelming volume of data to gather. Or when the breakthrough is beyond the reach of current scientific knowledge.</p>

<p>Citizen scientists may be constrained by money, but they tend to be unconstrained by expertise. Therefore they are likely to try solutions that experts would never consider. <a href="http://en.wikipedia.org/wiki/Wright_brothers">Orville and Wilbur Wright</a> were citizen scientists. Professional scientists pursued solutions for fixed-wing flight prior to the Wright brothers&#8217; success. But since the flight problem defied the known science of the day, new approaches were required.</p>

<p>Amusingly, successful citizen scientists can be outwitted by their own expertise, just like the professionals. For example&hellip;</p>

<blockquote><p>No flying machine will ever fly from New York to Paris &hellip;[because] no known motor can run at the requisite speed for four days without stopping.
<br/>~Orville Wright</p></blockquote>

<p>Shifting back to the 21st century: Thousands of citizen scientists are using OpenROV to explore oceans and lakes more thoroughly than ever before.</p>

<h3>Open Source On-Site</h3>

<p><span class='caption-wrapper right'><img class='caption' src='/images/ui-discussion-2.jpg' width='' height='' alt='Enthusiasts collaborate on the next UI.' title='Enthusiasts collaborate on the next UI.'><span class='caption-text'>Enthusiasts collaborate on the next UI.</span></span>
On the day I visited the OpenROV factory, other underwater enthusiasts were on-site, working with company engineers on product improvements. One enthusiast is a professional pilot of manned submersibles, underwater vehicles large enough to hold people. This pilot has traveled as deep as 2,000 meters below the ocean&rsquo;s surface! &ldquo;We&rsquo;re always looking at amperage&rdquo;, she said in a discussion with another enthusiast. A spike in amperage could indicate a ground fault, and batteries drain rapidly when that happens. You do not want to be stuck underwater when the batteries run out.</p>

<p>Another member of the open source community, an engineering veteran with decades of experience at <a href="http://apple.com">Apple</a> and <a href="http://oracle.com">Oracle</a>, translates the operator&rsquo;s feedback into code that might drive the next OpenROV user interface.</p>

<p>That&rsquo;s how open source works at OpenROV.</p>

<h3>Hardware Testing</h3>

<p><span class='caption-wrapper right'><img class='caption' src='/images/testing-motor-controller.jpg' width='' height='' alt='Testing new hardware.' title='Testing new hardware.'><span class='caption-text'>Testing new hardware.</span></span>
I offered to leave when the OpenROV team prepared to test some new components. After working in tech for decades, I&rsquo;ve learned to respect a company&rsquo;s right to protect secrets.</p>

<p>&ldquo;You forget that this is all open source,&rdquo; they told me. &ldquo;The schematics are already online, so there&rsquo;s nothing to hide. Come and watch the test.&rdquo;</p>

<p>Yes, they had to remind me about the real meaning of open source!</p>

<p>Four OpenROV makers gathered around a tank of water to test a new motor, controller, and propeller combination. They measured power utilization, propulsion, and temperature. Power utilization is important because the batteries need to last. Temperature matters because we don&rsquo;t want the OpenROV to melt underwater (or fry the fish). And propulsion matters because if the unit can&rsquo;t move, what&rsquo;s the point?</p>

<p>From the reaction of the team, it looks like they found some good components for the next batch of OpenROV kits.</p>

<h3>Strong Minds Coming Together</h3>

<p>The mood in the OpenROV lab is a blend of excitement and technical expertise. Some of the people in the lab are members of the company. Others are adventurers fascinated with this inexpensive, effective way to explore. All are united in the quest to do something awesome with technology.</p>

<p>OpenROV is what we get when the thirst for exploration blends with the open source movement. What a wonderful combination.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BeagleBone Black Running Ubuntu: Part2 (Plus Ruby on Rails)]]></title>
    <link href="http://RayHightower.com/blog/2014/01/06/beaglebone-black-ubuntu-ruby-rails-part-2/"/>
    <updated>2014-01-06T02:31:00-06:00</updated>
    <id>http://RayHightower.com/blog/2014/01/06/beaglebone-black-ubuntu-ruby-rails-part-2</id>
    <content type="html"><![CDATA[<p><span class='caption-wrapper right'><img class='caption' src='/images/ruby-rails-ubuntu-beaglebone-black.png' width='' height='' alt='Ruby. Rails. Ubuntu. BeagleBone Black.' title='Ruby. Rails. Ubuntu. BeagleBone Black.'><span class='caption-text'>Ruby. Rails. Ubuntu. BeagleBone Black.</span></span></p>

<p>Part one of this series shows <a href="/blog/2014/01/02/beaglebone-black-ubuntu-part-1/">how to install Ubuntu on the BeagleBone Black</a>. We used a MacBook Pro to burn an Ubuntu disk image onto an SD card, and then we booted a BeagleBone Black from the image we created.</p>

<p>This post, part two, covers the installation of the Ubuntu GUI, Ruby, and Rails. All of the commands in this article are run on the BeagleBone Black.</p>

<p><a href="http://nodejs.org">Node.js</a> bonus: Rails requires a JavaScript runtime, and Node.js offered the quickest way to fulfill this requirement. Details appear within.</p>

<h3>Gotcha: Partition Size</h3>

<p>At the end of <a href="/blog/2014/01/02/beaglebone-black-ubuntu-part-1/">part one</a>, we successfully booted the Bone with the Ubuntu command line interface. Now it&rsquo;s time to add the GUI. Two things to know about the Ubuntu GUI installation&hellip;</p>

<!--more-->


<ul>
<li>The partition we created on the SD card (in part one) is too small to hold the Ubuntu GUI. Solution: The SD card has some extra room, and we can re-size the partition.</li>
<li>We can install the Ubuntu GUI with a single line command. But it takes an hour for the Bone to download, compile, and install all of the GUI libraries.</li>
</ul>


<p>If we try to install the GUI with insufficient space, the installation will fail midway and we will have wasted half an hour. So it&rsquo;s best to re-size first.</p>

<h3>Doing Our Own Re-Sizing?</h3>

<p>Why didn&rsquo;t the partition have the right size when we originally downloaded the image file? Good question.</p>

<p>My guess: The image file was designed to be as small as possible in order to minimize download time. That makes sense. I plan to test this theory by creating a new image with a larger partition size and a pre-installed GUI. If the test is successful, results will be posted on this blog. If the mission fails, then the secretary will disavow any knowledge&hellip;</p>

<h3>How to Re-Size the Partition</h3>

<p><code>df</code> is the Unix &lsquo;disk free&rsquo; command. It shows used/available disk space.</p>

<p>&#8220;` bash
ubuntu@ubuntu-armhf:~$ df</p>

<p>Filesystem     1K-blocks    Used Available Use% Mounted on
rootfs           3778576 2722944    885776  76% /
/dev/root        3778576 2722944    885776  76% /
devtmpfs          253580       4    253576   1% /dev
none               50748     608     50140   2% /run
none                5120       0      5120   0% /run/lock
none              253728     204    253524   1% /run/shm
/dev/mmcblk0p1      1004     480       524  48% /boot/uboot
/dev/mmcblk1p1     65390    6536     58854  10% /media/boot
/dev/mmcblk1p2   1748200    2664   1655068   1% /media/rootfs</p>

<p>ubuntu@ubuntu-armhf:~$</p>

<p>&#8220;`</p>

<p><code>ll</code> is one of the useful aliases built into Ubuntu&rsquo;s <code>.bashrc</code> file. We can use it to examine the partitions on the SD card.</p>

<p>&#8220;` bash
ubuntu@ubuntu-armhf:~$ ll /dev/mmcblk*</p>

<p>brw-rw&mdash;&mdash; 1 root disk 179,  0 Jan  5 15:37 /dev/mmcblk0
brw-rw&mdash;&mdash; 1 root disk 179,  1 Jan  1  2000 /dev/mmcblk0p1
brw-rw&mdash;&mdash; 1 root disk 179,  2 Jan  1  2000 /dev/mmcblk0p2
brw-rw&mdash;&mdash; 1 root disk 179,  8 Jan  1  2000 /dev/mmcblk1
brw-rw&mdash;&mdash; 1 root disk 179, 16 Jan  1  2000 /dev/mmcblk1boot0
brw-rw&mdash;&mdash; 1 root disk 179, 24 Jan  1  2000 /dev/mmcblk1boot1
brw-rw&mdash;&mdash; 1 root disk 179,  9 Jan  1  2000 /dev/mmcblk1p1
brw-rw&mdash;&mdash; 1 root disk 179, 10 Jan  1  2000 /dev/mmcblk1p2</p>

<p>ubuntu@ubuntu-armhf:~$</p>

<p>&#8220;`</p>

<p><code>fdisk</code> will resize the partition we&rsquo;re after. <code>root</code> priviledges are required to modify the partition table, so we&rsquo;ll use <code>sudo</code>. The standard <a href="/sudo-disclaimer">sudo disclaimer</a> applies.</p>

<p>A few useful <code>fdisk</code> commands:</p>

<ul>
<li><code>p</code> prints the partition table.</li>
<li><code>d</code> deletes a partition.</li>
<li><code>n</code> creates a new partition.</li>
<li><code>w</code> write new information to the partition table.</li>
<li><code>q</code> quits fdisk.</li>
</ul>


<p>Here&rsquo;s the plan: In order to increase the size of <code>/dev/mmcblk0p2</code>, we will delete it, and then re-create it with a larger size. Note the use of the <code>d</code> and <code>n</code> commands in the following sequence. When <code>fdisk</code> asks us for the new partition number, type, first sector, and last sector, we will choose the defaults. Choosing the defaults will use all of the available space on the SD card.</p>

<p>Your numbers will vary depending on the size and configuration of your SD card, but the general procedure will be the same.</p>

<p>&#8220;` bash</p>

<p>ubuntu@ubuntu-armhf:~$ sudo fdisk /dev/mmcblk0
[sudo] password for ubuntu:</p>

<p>Command (m for help): p</p>

<p>Disk /dev/mmcblk0: 3965 MB, 3965190144 bytes
4 heads, 16 sectors/track, 121008 cylinders, total 7744512 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x80008000</p>

<pre><code>    Device Boot      Start         End      Blocks   Id  System
</code></pre>

<p>/dev/mmcblk0p1   *        2048      133119       65536    e  W95 FAT16 (LBA)
/dev/mmcblk0p2          133120     1638399      752640   83  Linux</p>

<p>Command (m for help): d
Partition number (1-4): 2</p>

<p>Command (m for help): p</p>

<p>Disk /dev/mmcblk0: 3965 MB, 3965190144 bytes
4 heads, 16 sectors/track, 121008 cylinders, total 7744512 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x80008000</p>

<pre><code>    Device Boot      Start         End      Blocks   Id  System
</code></pre>

<p>/dev/mmcblk0p1   *        2048      133119       65536    e  W95 FAT16 (LBA)</p>

<p>Command (m for help): n
Partition type:
   p   primary (1 primary, 0 extended, 3 free)
   e   extended
Select (default p): p
Partition number (1-4, default 2): 2
First sector (133120-7744511, default 133120):
Using default value 133120
Last sector, +sectors or +size{K,M,G} (133120-7444511, default 7744511):
Using default value 7744511</p>

<p>Command (m for help): p</p>

<p>Disk /dev/mmcblk0: 3965 MB, 3965190144 bytes
4 heads, 16 sectors/track, 121008 cylinders, total 7744512 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x80008000</p>

<pre><code>    Device Boot      Start         End      Blocks   Id  System
</code></pre>

<p>/dev/mmcblk0p1   *        2048      133119       65536    e  W95 FAT16 (LBA)
/dev/mmcblk0p2          133120     7744511     3805696   83  Linux</p>

<p>Command (m for help): w
The partition table has been altered!</p>

<p>Calling ioctl() to re-read partition table.</p>

<p>Warning: Re-reading the partition table failed with error 16: Device or resource busy.
The kernel still uses the old table. The new table will b eused at
the next reboot or after you run partprobe(8) or kpartx(8)
Syncing disks.</p>

<p>ubuntu@ubuntu-armhf:~$</p>

<p>&#8220;`</p>

<p>The warning/error message at the end just means that we need reboot the Bone before the partition table takes effect.</p>

<p>Reboot the BeagleBone Black, holding down the boot switch (closest to the USB port) to ensure that we boot to the system on the SD card instead of the eMMC.</p>

<p>After the Bone reboots, run <code>resize2fs</code> to expand the partition created above.</p>

<p>&#8220;` bash</p>

<p>ubuntu@ubuntu-armhf:~$ sudo resize2fs /dev/mmcblk0p2
[sudo] password for ubuntu:
resize2fs 1.42.5 (29-Jul-2012)
Filesystem at /dev/mmcblk0p2 is mounted on /; on-line resizing required
old_desc_blocks = 1, new_desc_blocks = 1
The filesystem on /dev/mmcblk0p2 is now 951424 blocks long.</p>

<p>ubuntu@ubuntu-armhf:~$</p>

<p>&#8220;`</p>

<p>And now we have enough room to install the Ubuntu GUI.</p>

<h3>Installing the Ubuntu GUI</h3>

<p><em>Update (Feb2014): In the comments below, Jonathan Chan describes how he updated the desktop installation files before installing the Ubuntu desktop. To update the desktop installation files, grab the latest list of packages (<code>update</code>) and then <code>upgrade</code> the packages that need it.</em></p>

<p>&#8220;` bash</p>

<p>$ sudo apt-get update</p>

<p>$</p>

<p>$ sudo apt-get upgrade</p>

<p>$</p>

<p>&#8220;`</p>

<p>After the partition on the SD card has been resized, this command will intall the GUI. The command is short, but the process takes about an hour:</p>

<p>&#8220;` bash</p>

<p>$ sudo apt-get install ubuntu-desktop</p>

<p>&#8220;`</p>

<p>When installation and compilation are complete, Ubuntu will return to the command prompt. Here&rsquo;s how to reboot:</p>

<p><code>bash
$ sudo reboot
</code></p>

<p>Several minutes later, the Ubuntu 12 GUI will appear. Congratulations!  Login using the default credentials (login: ubuntu, pw: ubuntu) to get to the Ubuntu desktop.</p>

<h3>Gotcha: Running RVM</h3>

<p>I prefer to use the Ruby Version Manager (RVM) for bouncing between Ruby versions. RVM misbehaved, initially. Then I learned something special about RVM&rsquo;s interaction with Ubuntu. From the RVM support pages…</p>

<blockquote><p>For RVM to work properly, you have to set the &lsquo;Run command as login shell&rsquo; checkbox on the Title and Command tab inside of gnome-terminal&rsquo;s Settings page.</p></blockquote>

<p>This image shows the checkbox mentioned in the quote. It&rsquo;s inside of the lower red rectangle.</p>

<p><span class='caption-wrapper'><img class='caption' src='/images/rvm-ubuntu-run-command_as_login-shell.jpg' width='' height='' alt='RVM: Run command as login shell.' title='RVM: Run command as login shell.'><span class='caption-text'>RVM: Run command as login shell.</span></span></p>

<p>Details are in the RVM support article <a href="http://rvm.io/integration/gnome-terminal">Integrating RVM with gnome-terminal</a>.</p>

<h3>Gotcha: Ruby Installation</h3>

<p>Ruby installation initially failed (speculation) because the Bone went into power save mode during the installation process. Ruby installed successfully on the second try when I kept the machine awake by moving the mouse. This <em>power save hypothesis</em> has not been thoroughly tested.</p>

<h3>Gotcha: Rails Installation</h3>

<p><span class='caption-wrapper right'><img class='caption' src='/images/nodejs-white.png' width='' height='' alt='Node.js on BeagleBone Black.' title='Node.js on BeagleBone Black.'><span class='caption-text'>Node.js on BeagleBone Black.</span></span>
Rails needs a JavaScript runtime in order to function. Here are two ways to meet this requirement:</p>

<ul>
<li>Install Node.js, or</li>
<li>Install <a href="http://rubygems.org/gems/therubyracer">therubyracer</a> gem.</li>
</ul>


<p>Installing <code>therubyracer</code> did not work for me. But Node.js installed quickly, like so:</p>

<p><code>bash
$ sudo apt-get install nodejs
</code></p>

<p>Now that we have a JavaScript runtime, Rails runs successfully.</p>

<p>Side note: If you want to see what a Node.js-equipped Bone can do, check
out <a href="http://openrov.com">OpenROV</a>.</p>

<h3>Conclusion</h3>

<p>Bottom line: Ruby, Rails, and Ubuntu can run successfully on BeagleBone Black, with Node.js as a bonus.</p>

<p>The BeagleBone Black is a cool option for running Ubuntu. Yes, it runs slower than a typical laptop. But it runs, and at $45 each we can build a cluster of Bones if we&rsquo;re concerned about performance!</p>

<p>What an amazing bundle of technology.</p>

<p><em>You might also be interested in <a href="/blog/2012/12/03/ruby-on-raspberry-pi/">Ruby on Raspberry Pi</a></em>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BeagleBone Black Running Ubuntu: Part1]]></title>
    <link href="http://RayHightower.com/blog/2014/01/02/beaglebone-black-ubuntu-part-1/"/>
    <updated>2014-01-02T15:59:00-06:00</updated>
    <id>http://RayHightower.com/blog/2014/01/02/beaglebone-black-ubuntu-part-1</id>
    <content type="html"><![CDATA[<p><span class='caption-wrapper center'><img class='caption' src='/images/beaglebone-black-ubuntu-ruby-rails.jpg' width='' height='' alt='BeagleBone Black running Ubuntu, Ruby, &amp; Rails.' title='BeagleBone Black running Ubuntu, Ruby, &amp; Rails.'><span class='caption-text'>BeagleBone Black running Ubuntu, Ruby, &amp; Rails.</span></span></p>

<p>The above screenshot shows a BeagleBone Black running Ubuntu, Ruby, and Rails. Why Ubuntu? The Bone comes <a href="/blog/2013/05/22/beaglebone-black-running-ruby-on-rails/">pre-installed with Ångström</a>, and it boots as soon as you unbox it. Why not stick with Ångström?</p>

<p>My opinion: The factory standard is fine, but it&rsquo;s always good to have options. Here&rsquo;s why I decided to try Ubuntu on the BeagleBone Black&hellip;</p>

<!--more-->


<ul>
<li>Ubuntu documentation is plentiful. Books, blogs, and videos are readily available.</li>
<li>The Ubuntu community is huge. When a dev runs into an Ubuntu-related snag, it&rsquo;s likely that another dev has encountered a similar problem, and they can collaborate on a solution.</li>
<li>Ubuntu is the distro that I&rsquo;m most familiar with. <a href="http://wisdomgroup.com">WisdomGroup</a> uses Ubuntu for multiple projects. With a common operating system, knowledge gained in one environment is immediately useful in another.</li>
<li>Prepping for <a href="/blog/2013/06/22/preparing-for-parallella-64-cores-installing-go-on-mac-os-x/">Parallella</a>, the 64-core single-board computer that will cost about two hundred bucks. The Parallella is currently in short supply. When it becomes available, it will run Ubuntu. Experience with other single-board computers, especially those running Ubuntu, will prove useful.</li>
</ul>


<p>This article will show how to install Ubuntu on the BeagleBone Black. <em>Gotchas</em> will be pointed out along the way. Where possible, I will explain the reasons behind my decisions so that you can make different choices if you like.</p>

<p>For a comparable examination of the Raspberry Pi, take a look at <a href="/blog/2012/12/03/ruby-on-raspberry-pi/">Ruby on Raspberry Pi</a>.</p>

<h3>First Gotcha: Ubuntu 13 on the Bone</h3>

<p>As of this writing, Ubuntu 12 runs well on the BeagleBone Black, but Ubuntu 13 does not. My Ubuntu 13 installation appeared to be successful, but the Ubuntu 13 GUI hung up immediately after login. The Ubuntu 13 command line interface worked fine.</p>

<p>A quick search on Google reveals that others encountered similar roadblocks with version 13. One successful Bone/13 installation was used via SSH, not interactively via keyboard and GUI. Hopefully this will change with future updates. Or, since we&rsquo;re dealing in the open source world, maybe I can pitch in and help.</p>

<p>Due to the issues encountered with version 13, everything in this article will focus on Ubuntu 12.</p>

<h3>Materials Needed for Installing Ubuntu 12</h3>

<p>In addition to the BeagleBone Black, the following items should be gathered before installation:</p>

<ul>
<li>Micro SD card of at least 8GB. It&rsquo;s possible to perform the installation with a 4GB card, but that won&rsquo;t leave much room for Ubuntu applications.</li>
<li>SD card reader/writer. Recent versions of Apple&rsquo;s MacBook Pro come with an SD reader/writer built in.</li>
<li>SD to Micro-SD card adapter. The Bone is designed for micro SD, and the MacBook Pro is designed for full-sized SD. Some micro SD packages come with the adapter.</li>
<li>A monitor that accepts HDMI input.</li>
<li>USB keyboard and mouse.</li>
<li>Micro HDMI to HDMI adapter. The Bone uses micro HDMI for video output, but your monitor probably uses full-sized HDMI.</li>
<li>External 5V power adapter for the Bone. Personally, I trust the standard 5v power input more than I trust the power provided via USB. One never knows if USB can provide sufficient (and stable) amperage for a circuit board. Power fluctuations can lead to strange behavior, including video flickering.</li>
<li>Ethernet cable with RJ-45 ends.</li>
<li>A fast internet connection.</li>
</ul>


<p>The standard <a href="/sudo-disclaimer">sudo disclaimer</a> applies.</p>

<h3>Homebrew Required</h3>

<p>Homebrew is the easiest way to install &lsquo;nix utilities on Mac OS X. We need Homebrew in order to install some of the utilities needed to burn the SD card. The one-line Homebrew installation command is given on the  <a href="http://brew.sh/">Homebrew site</a>.</p>

<p>Each time we use Homebrew, we run <code>$ brew doctor</code> and <code>$ brew update</code> to make sure the packages are up-to-date.</p>

<p>&#8220;` bash</p>

<p>$ brew doctor
Warning: Your Homebrew is outdated.
You haven&rsquo;t updated for at least 24 hours, this is a long time in brewland!
To update Homebrew, run <code>brew update</code>.</p>

<p>$ brew update
Updated Homebrew from a2e44659 to 4c7bc9ec.</p>

<p>$ brew doctor
Your system is ready to brew.</p>

<p>&#8220;`</p>

<h3>The xz Extraction Utility</h3>

<p>Disk image files are downloaded in a compressed format. We need the <code>xz</code> utility in order to extract the files into something usable. If you already have Homebrew installed, this command will install <code>xz</code> for you.</p>

<p>&#8220;` bash</p>

<p>$ brew install xz</p>

<p>&#8220;`</p>

<h3>Test the BeagleBone Black First</h3>

<p>Power up your BeagleBone Black and make sure it runs with the built-in Ångström Linux installation. One great thing about the Bone is that it will <a href="/blog/2013/05/22/beaglebone-black-running-ruby-on-rails/">boot to the Ångström GUI</a> straight out of the box, with no prior configuration.</p>

<p>If the GUI boots, then you&rsquo;re in good shape.</p>

<p>If the GUI doesn&rsquo;t boot, it may have been damaged in a prior experiement. Embarassing note: I started looking for a way to install Ubuntu on the Bone because I broke my Ångström installation. What can I say&hellip; I learn more from destructive experiments. Faced with a non-booting Bone, I had two choices.</p>

<ol>
<li>Re-build Ångström.</li>
<li>Try something different, like Ubuntu.</li>
</ol>


<p>Option two worked well!</p>

<h3>Prep the SD Card</h3>

<p>Apple&rsquo;s Disk Utility is a convenient tool for wiping the SD card.  Standard warnings about any disk utility apply. Double-check everything, and make sure you&rsquo;re wiping the right volume, or you could lose all of your data.</p>

<p>Next, download the Ubuntu 12.04 image from <a href="http://www.armhf.com/index.php/boards/beaglebone-black/#precise">http://armhf.com</a>.</p>

<p>Extract the image using the <code>xz</code> utility.</p>

<p>&#8220;` bash</p>

<p>$ xz ubuntu-precise-12.04.3-armhf-3.8.13-bone30.img.xz</p>

<p>&#8220;`</p>

<p>The extracted image will have a <code>.img</code> file extension. We will use the <code>dd</code> utility to burn the disk image to the SD card. But first, we need to determine the designation of the SD card.</p>

<h3>Find the SD Card Designation</h3>

<p>In order to burn the SD card, we need to make sure we target it correctly. Here&rsquo;s how to figure out which device to target.</p>

<p><code>$ diskutil list</code> will show all of the partitions mounted on the system.</p>

<p>&#8220;` bash</p>

<p>$ diskutil list
/dev/disk0
   #:                       TYPE NAME                    SIZE       IDENTIFIER
   0:      GUID_partition_scheme                        <em>500.3 GB   disk0
   1:                        EFI                         209.7 MB   disk0s1
   2:                  Apple_HFS Macintosh HD            499.4 GB   disk0s2
   3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3
/dev/disk1
   #:                       TYPE NAME                    SIZE       IDENTIFIER
   0:     FDisk_partition_scheme                        </em>8.0 GB     disk1</p>

<p>&#8220;`</p>

<p>I happen to know that my SD Card is 8.0 GB in capacity, and my system also has a 500 GB SSD. The goal is to burn the SD card while leaving the 500 GB SSD (home of the Mac OS X operating system and all of my data) intact. From the <code>$ diskutil list</code> report, I can see that the SD card&rsquo;s designation <em>in my system</em> is <code>/dev/disk1</code>.</p>

<p>Note the italicized words <em>in my system</em>. Your system is probably different, especially if you have a DVD drive or a second hard drive. I have neither of those. The SD card&rsquo;s designation will be different in each system where it is mounted depending on the number and location of the drives that are already there.</p>

<p>Now that we know the SD card&rsquo;s designation, we can unmount it. We unmount the drive (but leave the card inserted in the reader) so that it can be written with the Ubuntu disk image.</p>

<p>&#8220;` bash</p>

<p>$ diskutil unmountDisk /dev/disk1
Unmount of all volumes on disk1 was successful</p>

<p>&#8220;`</p>

<p>Looks like the SD card was unmounted successfully. Now we can write the
Ubuntu image with the <code>dd</code> utility.</p>

<h3>Writing the Ubuntu Image</h3>

<p>The following command will write the decompressed Ubuntu image to the SD
card.</p>

<p>&#8220;` bash</p>

<p>$ sudo dd bs=1m if=ubuntu-precise-12.04.3-armhf-3.8.13-bone30.img of=/dev/disk1</p>

<p>&#8220;`</p>

<p>Note that it may take up to an hour for the image to be written.</p>

<p>One drawback of using the command line is that there is no gauge to tell you how much progress the utility is making. Fortunately, I stumbled upon a way to measure progress at <a href="http://elinux.org">eLinux.org</a>. While the command line utility is running, and while that window has focus, type <code>control-T</code>. A few seconds later, the terminal window will show a brief activity report.</p>

<p>Here&rsquo;s a report from the first time I struck <code>control-T</code> &hellip;</p>

<p>&#8220;` bash</p>

<p>load: 2.03  cmd: dd 75608 uninterruptible 0.00u 0.54s
40+0 records in
39+0 records out</p>

<p>&#8220;`</p>

<p>We can strike <code>control-T</code> again to receive additional updates. The numbers will tell us if we are making progress. Don&rsquo;t get carried away with <code>control-T</code>. A watched pot never boils :&ndash;)</p>

<h3>Booting with the New SD Card</h3>

<p>The terminal will return to the command prompt after the Ubuntu image has been written to the SD card. Now it&rsquo;s time to boot with the new image.</p>

<ol>
<li>Eject the SD card from the Mac.</li>
<li>Remove power from the BeagleBone Black, and insert the micro SD card.</li>
<li>Note the location of the &ldquo;boot&rdquo; button on the Bone. It&rsquo;s the micro switch closest to the USB port. We will need to hold this switch down while powering up the Bone.</li>
</ol>


<p>A few notes about item #3. It takes some juggling to hold down a micro switch while plugging in power to the board. I found it easier to plug the power adapter into a powered-off surge suppressor, hold down the microswitch, and then power-on the surge suppressor with my elbow.  Sounds ridiculous, but it worked.</p>

<p>About sixty seconds after boot, the Linux penguin appeared in the upper left corner of the Bone display. And then the login prompt appeared.</p>

<p>Another note about the &ldquo;boot&rdquo; switch: It looks like the Bone will boot into the SD&rsquo;s operating system (instead of the eMMC flash OS where Angstrom resides) without the micro switch if the switch was used in the previous boot. I haven&rsquo;t rebooted enough times to test this thoroughly.</p>

<h3>Default Credentials for Ubuntu on BeagleBone Black</h3>

<p>Ubuntu&rsquo;s default BeagleBone Black login credentials are shown here because I always end up hunting for these when I need them. It&rsquo;s much easier to have information at one&rsquo;s fingertips.</p>

<p>&#8220;` bash</p>

<p>login: ubuntu
pw: ubuntu</p>

<p>&#8220;`</p>

<h3>End of Part One</h3>

<p>This marks the end of part one of this series about BeagleBone Black and Ubuntu.</p>

<p><a href="/blog/2014/01/06/beaglebone-black-ubuntu-ruby-rails-part-2/">Part two</a> covers <a href="/blog/2014/01/06/beaglebone-black-ubuntu-ruby-rails-part-2/">Ruby on BeagleBone Black</a>, with information about&hellip;</p>

<ul>
<li>Getting the GUI running, including a disk resizing <em>gotcha</em>.</li>
<li>Installing Ruby, including a Ruby Version Manager (RVM) <em>gotcha</em>.</li>
<li>Installing Rails, and how to handle a JavaScript runtime <em>gotcha</em>.</li>
</ul>


<p>Stay tuned!</p>
]]></content>
  </entry>
  
</feed>
